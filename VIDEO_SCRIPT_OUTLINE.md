# PotPlayer AI字幕翻译插件 - 功能演进主线（讲演大纲）

## 开场
- 字幕翻译存在的问题
- 本插件的解决思路
- 功能演进历程概览

---

## 第一部分：上下文处理
**问题**
- 单条字幕无法确定代词指代
- 缺少对话背景导致翻译模糊

**初期考虑的多个方案**

**方案1：保存全部历史字幕**
- 想法：这样AI能看到所有背景
- 问题：成本太高、延迟严重、容易互相干扰
- 结果：放弃

**方案2：动态调整历史长度**
- 想法：根据字幕内容动态增加或减少历史条数
- 问题：判断逻辑复杂，难以调优
- 结果：放弃

**方案3：按字符数而不是条数保存**
- 想法：保存固定的字符数而不是固定的条数
- 问题：不同语言字符数差异大，标准难定
- 结果：放弃

**最终解决方案**
- 维护滑动窗口（默认5条）
- 每次翻译时包含前文历史
- AI 获得完整对话背景
- 简单、可控、高效

**为什么是5条？**
- 成本平衡（推荐3-5，可调1-10）
- 延迟可控（足够理解对话流）
- 避免上下文污染
- 实测效果最优

### 示例演示：上下文处理效果对比

---

## 第二部分：上下文智能判断
**升级问题**
- 电影/剧集出现场景切换
- 旧上下文在新场景失效
- 如果继续用就会导致翻译错误

**被考虑的方案（这些都试过）**

**方案1：通过PotPlayer API获取播放信息**
- 想法：直接从播放器获取当前时间戳和文件信息
- 尝试：查了API文档和源代码
- 现实：字幕插件权限限制，无法访问播放器实时信息
- 结果：完全不可行

**方案2：通过字幕文件本身的时间记录**
- 想法：用字幕的时间码来推断场景变化
- 尝试：分析字幕格式（SRT/ASS），提取时间戳
- 问题：时间码变化≠场景变化，容易误判
- 成本：需要额外的字幕解析逻辑
- 结果：过于复杂，收益不足

**方案3：字符数差异检测**
- 想法：新字幕和最后一条字幕差异大就清空
- 问题：字符数变化不等于场景切换，误报太多
- 结果：放弃

**方案4：AI自动判断是否清空**
- 想法：让AI自己决定要不要用上下文
- 问题：额外的API调用，成本倍增
- 结果：放弃

**最终解决方案（系统时间戳）**
- 采用系统时间戳（HostGetTickCount()）
- 每次翻译记录时间
- 超过阈值自动清空历史
- 防止跨场景的上下文污染

**关键机制**
- 下次翻译时对比时间差
- 超过阈值立即清空
- 简单可靠，零额外成本

### 示例演示：场景切换的自动清空机制

---

## 第三部分：可配置场景阈值
**升级问题**
- 固定6秒不适合所有内容
- 快速场景切换（动漫）
- 场景相对稳定（电影）

**初期的妥协方案**
- 方案1：针对每个内容类型写死参数
  - 问题：用户如果内容特殊，就无法调整
  - 结果：不够灵活

**最终解决方案**
- 用户可自定义阈值
- 9种内容类型预设值
- 支持1-60000毫秒配置

**配置灵活性**
- 性能优先：设置小阈值（快速清空）
- 一致性优先：设置大阈值（保留更多上下文）
- 默认6000ms是黄金平衡点

### 示例演示：不同阈值配置对翻译的影响

---

## 第3.5部分：口语化翻译与俚语识别

**口语化翻译**
- 问题：AI倾向于书面语，不够自然
- 解决方案：针对性的Prompt优化
- 效果：翻译更口语、更接地气

**俚语和习语识别**
- 问题：俚语和习语无法直译
- 方案1：依赖AI自动识别
  - 问题：效果不稳定，依赖模型训练数据
  - 结果：不够可靠
  
- 最终方案：内置15+个俚语数据库
- 支持多种内容类型的常见俚语
- AI看到俚语提示后能更准确地翻译

### 示例演示：俚语识别前后的翻译对比

---

## 第3.6部分：多语言文化适配

**问题**
- 同一句话在不同文化背景下的理解不同
- 简单翻译无法传达文化含义

**解决方案**
- 针对不同源语言的文化特性优化
- 支持：英文、日文、韩文、法文等
- 每种语言配置独特的翻译提示

**例子**
- 英文：直接、幽默、重视逻辑
- 日文：敬语系统、间接表达、尊重
- 韩文：家族关系用语、敬语多样

### 示例演示：文化适配前后的翻译质量对比

---

## 第3.7部分：AI自检机制

**问题**
- 翻译完成后无法保证质量
- AI有时会出现明显错误

**解决方案**
- 5点质量验证体系：
  - 检查是否保留了专有名词
  - 检查句子逻辑是否通顺
  - 检查术语是否一致
  - 检查是否有明显翻译错误
  - 检查文化适配是否恰当

**机制**
- AI先生成翻译
- 再对翻译进行自检
- 如果发现问题就重新翻译
- 确保输出质量

### 示例演示：自检机制改进翻译质量

---

## 第3.8部分：9种内容类型预设

**问题**
- 不同内容有不同的翻译风格需求
- 一套Prompt无法适应所有类型

**解决方案**
- 针对9种常见内容类型预设不同的翻译规则：
  - anime（日本动漫）
  - western-comic（美漫）
  - scifi（科幻）
  - fantasy（奇幻）
  - drama（剧情）
  - horror（恐怖）
  - disney（迪士尼风格）
  - gamedev（游戏）
  - general（通用）

**效果**
- 动漫翻译保留敬语和动漫术语
- 美漫翻译保留夸张、幽默风格
- 科幻翻译使用专业技术术语
- 等等

### 示例演示：不同类型下的翻译风格对比

---

## 第3.9部分：翻译缓存系统

**问题**
- 同一部电影经常有重复字幕
- 重复翻译浪费成本和时间

**解决方案**
- 全量缓存：保存所有历史翻译
- 优先查缓存，减少API调用
- 成本显著下降（可节省30-50%的API调用）

**两层缓存**
- 全量缓存：整个观看历史
- 上下文缓存：当前连续场景的5条

### 示例演示：缓存对翻译成本和速度的影响

---

## 第四部分：电影背景集成的探索
**核心问题**
- 背景信息如何自动获取？
- 如何不增加用户负担？

**被推翻的方案对比**

**方案A：自动识别文件名**
- 想法：从PotPlayer获取当前播放的文件名
- 尝试：查了API文档
- 现实：字幕插件无法访问播放器信息（安全限制）
- 结果：完全不可行

**方案B：调用Windows API**
- 想法：自己调用系统API获取PotPlayer窗口信息
- 可行性：技术上可以做
- 代价：500+行复杂代码、易出错、兼容性差、性能差
- 收益：能自动识别一部分文件
- 结论：不值得

**方案C：用户手动输入（最终选择）**
- 简单：用户输入电影名
- 成本极低：1次TMDB API调用
- 缓存机制：后续使用内存缓存（零成本）
- 用户体验：配置一次，享受整部电影

**为什么选C？**
- 首次调用TMDB API搜索梗概（200ms）
- 后续全部使用内存缓存（零延迟）
- 对100条字幕：1次API调用vs100次AI调用
- 成本差异：极小 vs 5-10%增加

### 示例演示：三种方案的原理和权衡

---

## 第五部分：混合背景方案（终章）
**升级问题**
- TMDB只有商业电影和电视剧
- 小众动漫、网络内容无法支持
- 用户可能有特殊翻译需求

**初期的局限**
- 方案1：只支持TMDB自动搜索
  - 问题：小众内容无解
  - 反馈：用户无法使用

**三模式系统的设计**

### 模式0：无背景（轻量版）
- 最轻量、最快、零成本
- 场景：只想要基础翻译，不在乎背景信息
- 适合用户：性能狂热者

### 模式1：TMDB自动搜索（推荐版）
- 自动化梗概获取
- 200ms首次延迟，后续零成本
- 场景：主流电影/电视剧
- 适合用户：追求自动化的用户（推荐）

### 模式2：用户自定义（高级版）
- 完全灵活的背景信息
- 零网络延迟、零API成本
- 支持：任何内容类型（动漫、游戏、同人作品等）
- 适合用户：有特殊需求的用户

**设计理念**
- 最小化复杂度（核心代码只增80-120行）
- 最大化灵活性（三种需求都满足）
- 优雅降级机制（功能失败不影响核心翻译）
- 稳定性第一，功能第二

### 示例演示：三种模式的配置和效果对比

---

## 尾声
- **核心功能演进**（5大部分）
  - 上下文处理：多种方案对比后选择5条滑动窗口
  - 上下文智能判断：从API到时间戳的演进
  - 可配置场景阈值：从固定到灵活的升级
  - 电影背景集成：三个被推翻的方案
  - 三模式混合方案：满足所有用户需求

- **增强功能模块**（4大部分）
  - 口语化翻译与俚语识别：15+数据库支持
  - 多语言文化适配：5种语言文化特性
  - AI自检机制：5点质量验证体系
  - 9种内容类型预设：精准适配各类内容

- **效率功能**
  - 翻译缓存系统：节省30-50%API调用

- **设计哲学**
  - 从问题 → 尝试 → 放弃 → 最优解的完整思考过程
  - 权衡与妥协的艺术
  - 为什么有些看似好的方案最终被放弃
  - 简单解决方案往往最有效

- 感谢观看
